digraph "" {
IERC721Metadata -> IERC721;
IERC721Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    tokenURI(uint256)</TD></TR></TABLE> >];

Pausable -> Context;
Pausable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Pausable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    paused()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _pause()</TD></TR><TR><TD align="left">    _unpause()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    whenNotPaused()</TD></TR><TR><TD align="left">    whenPaused()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _paused</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

EnumerableMap[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableMap</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _set(EnumerableMap.Map,bytes32,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableMap.Map,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableMap.Map,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableMap.Map)</TD></TR><TR><TD align="left">    _at(EnumerableMap.Map,uint256)</TD></TR><TR><TD align="left">    _get(EnumerableMap.Map,bytes32)</TD></TR><TR><TD align="left">    _get(EnumerableMap.Map,bytes32,string)</TD></TR><TR><TD align="left">    set(EnumerableMap.UintToAddressMap,uint256,address)</TD></TR><TR><TD align="left">    remove(EnumerableMap.UintToAddressMap,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableMap.UintToAddressMap,uint256)</TD></TR><TR><TD align="left">    length(EnumerableMap.UintToAddressMap)</TD></TR><TR><TD align="left">    at(EnumerableMap.UintToAddressMap,uint256)</TD></TR><TR><TD align="left">    get(EnumerableMap.UintToAddressMap,uint256)</TD></TR><TR><TD align="left">    get(EnumerableMap.UintToAddressMap,uint256,string)</TD></TR></TABLE> >];

SafeMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SafeMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    add(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256)</TD></TR><TR><TD align="left">    sub(uint256,uint256,string)</TD></TR><TR><TD align="left">    mul(uint256,uint256)</TD></TR><TR><TD align="left">    div(uint256,uint256)</TD></TR><TR><TD align="left">    div(uint256,uint256,string)</TD></TR><TR><TD align="left">    mod(uint256,uint256)</TD></TR><TR><TD align="left">    mod(uint256,uint256,string)</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _registerInterface(bytes4)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _INTERFACE_ID_ERC165</TD></TR><TR><TD align="left">    _supportedInterfaces</TD></TR></TABLE> >];

ChaiLike[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ChaiLike</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    dai(address)</TD></TR></TABLE> >];

DSChiefLike[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>DSChiefLike</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    votes(address)</TD></TR></TABLE> >];

FlipperLike[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>FlipperLike</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    bids(uint256)</TD></TR></TABLE> >];

MakerBadges -> Ownable [ label="1" ];
MakerBadges -> AccessControl [ label="2" ];
MakerBadges -> Pausable [ label="3" ];
MakerBadges -> BaseRelayRecipient [ label="4" ];
MakerBadges -> IKnowForwarderAddress [ label="5" ];
MakerBadges[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MakerBadges</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left">    setRootHashes(bytes32[])</TD></TR><TR><TD align="left">    chaiChallenge(uint256)</TD></TR><TR><TD align="left">    chiefChallenge(uint256)</TD></TR><TR><TD align="left">    flipperChallenge(uint256,uint256)</TD></TR><TR><TD align="left">    verify(uint256,address)</TD></TR><TR><TD align="left">    addAdmin(address)</TD></TR><TR><TD align="left">    removeAdmin(address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><font color="#FFA500">    versionRecipient()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTrustedForwarder()</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgSender()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgData()</font></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyAdmin()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    ADMIN_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR><TR><TD align="left">    roots</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    chai<font color="blue" POINT-SIZE="10"> (ChaiLike)</font></TD></TR><TR><TD align="left">    chief<font color="blue" POINT-SIZE="10"> (DSChiefLike)</font></TD></TR><TR><TD align="left">    flipper<font color="blue" POINT-SIZE="10"> (FlipperLike)</font></TD></TR><TR><TD align="left">    redeemers</TD></TR></TABLE> >];

BadgeRoles -> Ownable [ label="1" ];
BadgeRoles -> AccessControl [ label="2" ];
BadgeRoles -> Pausable [ label="3" ];
BadgeRoles -> BaseRelayRecipient [ label="4" ];
BadgeRoles -> IKnowForwarderAddress [ label="5" ];
BadgeRoles[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BadgeRoles</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    addTemplater(address)</TD></TR><TR><TD align="left">    removeTemplater(address)</TD></TR><TR><TD align="left">    pause()</TD></TR><TR><TD align="left">    unpause()</TD></TR><TR><TD align="left"><font color="#FFA500">    versionRecipient()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTrustedForwarder()</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgSender()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgData()</font></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyAdmin()</TD></TR><TR><TD align="left">    onlyTemplater()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    TEMPLATER_ROLE</TD></TR><TR><TD align="left">    PAUSER_ROLE</TD></TR></TABLE> >];

GsnTypes[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GsnTypes</B></TD></TR></TABLE> >];

IERC721Enumerable -> IERC721;
IERC721Enumerable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Enumerable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    tokenOfOwnerByIndex(address,uint256)</TD></TR><TR><TD align="left">    tokenByIndex(uint256)</TD></TR></TABLE> >];

BasePaymaster -> IPaymaster [ label="1" ];
BasePaymaster -> Ownable [ label="2" ];
BasePaymaster[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BasePaymaster</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    getHubAddr()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getGasLimits()</font></TD></TR><TR><TD align="left">    _verifyForwarder(GsnTypes.RelayRequest)</TD></TR><TR><TD align="left">    setRelayHub(IRelayHub)</TD></TR><TR><TD align="left">    setTrustedForwarder(IForwarder)</TD></TR><TR><TD align="left"><font color="#FFA500">    getRelayHubDeposit()</font></TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left">    withdrawRelayHubDepositTo(uint256,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    relayHubOnly()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    trustedForwarder<font color="blue" POINT-SIZE="10"> (IForwarder)</font></TD></TR><TR><TD align="left">    FORWARDER_HUB_OVERHEAD</TD></TR><TR><TD align="left">    PRE_RELAYED_CALL_GAS_LIMIT</TD></TR><TR><TD align="left">    POST_RELAYED_CALL_GAS_LIMIT</TD></TR><TR><TD align="left">    PAYMASTER_ACCEPTANCE_BUDGET</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    relayHub<font color="blue" POINT-SIZE="10"> (IRelayHub)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

IStakeManager[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IStakeManager</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    stakeForAddress(address,uint256)</TD></TR><TR><TD align="left">    unlockStake(address)</TD></TR><TR><TD align="left">    withdrawStake(address)</TD></TR><TR><TD align="left">    authorizeHubByOwner(address,address)</TD></TR><TR><TD align="left">    authorizeHubByManager(address)</TD></TR><TR><TD align="left">    unauthorizeHubByOwner(address,address)</TD></TR><TR><TD align="left">    unauthorizeHubByManager(address)</TD></TR><TR><TD align="left">    isRelayManagerStaked(address,address,uint256,uint256)</TD></TR><TR><TD align="left">    penalizeRelayManager(address,address,uint256)</TD></TR><TR><TD align="left">    getStakeInfo(address)</TD></TR><TR><TD align="left">    versionSM()</TD></TR></TABLE> >];

ERC721 -> Context [ label="1" ];
ERC721 -> ERC165 [ label="2" ];
ERC721 -> IERC721 [ label="3" ];
ERC721 -> IERC721Metadata [ label="4" ];
ERC721 -> IERC721Enumerable [ label="5" ];
ERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    ownerOf(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left">    baseURI()</TD></TR><TR><TD align="left"><font color="#FFA500">    tokenOfOwnerByIndex(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    tokenByIndex(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getApproved(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _safeTransfer(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _exists(uint256)</TD></TR><TR><TD align="left">    _isApprovedOrOwner(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256)</TD></TR><TR><TD align="left">    _safeMint(address,uint256,bytes)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(uint256)</TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _setTokenURI(uint256,string)</TD></TR><TR><TD align="left">    _setBaseURI(string)</TD></TR><TR><TD align="left">    _checkOnERC721Received(address,address,uint256,bytes)</TD></TR><TR><TD align="left">    _approve(address,uint256)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _ERC721_RECEIVED</TD></TR><TR><TD align="left">    _holderTokens</TD></TR><TR><TD align="left">    _tokenOwners</TD></TR><TR><TD align="left">    _tokenApprovals</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR><TR><TD align="left">    _tokenURIs</TD></TR><TR><TD align="left">    _baseURI</TD></TR><TR><TD align="left">    _INTERFACE_ID_ERC721</TD></TR><TR><TD align="left">    _INTERFACE_ID_ERC721_METADATA</TD></TR><TR><TD align="left">    _INTERFACE_ID_ERC721_ENUMERABLE</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'supportsInterface(bytes4)' collides in inherited contracts IERC165, IERC165, IERC165, ERC165 where ERC165 is chosen.</font></TD></TR></TABLE> >];

IERC721Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC721Received(address,address,uint256,bytes)</TD></TR></TABLE> >];

MerkleProof[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MerkleProof</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    verify(bytes32[],bytes32,bytes32)</TD></TR></TABLE> >];

GsnUtils[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GsnUtils</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getMethodSig(bytes)</TD></TR><TR><TD align="left">    getParam(bytes,uint256)</TD></TR><TR><TD align="left">    revertWithData(bytes)</TD></TR></TABLE> >];

IERC721 -> IERC165;
IERC721[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    ownerOf(uint256)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    getApproved(uint256)</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,bytes)</TD></TR></TABLE> >];

MakerBadgesLike[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MakerBadgesLike</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    verify(uint256,address)</TD></TR><TR><TD align="left">    roots(uint256)</TD></TR></TABLE> >];

BadgeFactory -> BadgeRoles [ label="1" ];
BadgeFactory -> ERC721 [ label="2" ];
BadgeFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BadgeFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left">    setBaseURI(string)</TD></TR><TR><TD align="left">    createTemplate(string,string,string)</TD></TR><TR><TD align="left">    updateTemplate(uint256,string,string,string)</TD></TR><TR><TD align="left">    getTemplate(uint256)</TD></TR><TR><TD align="left">    getTemplatesCount()</TD></TR><TR><TD align="left">    activateBadge(bytes32[],uint256,string)</TD></TR><TR><TD align="left">    getBadgeTemplate(uint256)</TD></TR><TR><TD align="left">    getBadgeTemplateQuantity(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgSender()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgData()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _transfer(address,address,uint256)</font></TD></TR><TR><TD align="left">    _mintWithTokenURI(address,string)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    redeemed</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    maker<font color="blue" POINT-SIZE="10"> (MakerBadgesLike)</font></TD></TR><TR><TD align="left">    _templateIdTracker</TD></TR><TR><TD align="left">    _tokenIdTracker</TD></TR><TR><TD align="left">    templates</TD></TR><TR><TD align="left">    _templateQuantities</TD></TR><TR><TD align="left">    _tokenTemplates</TD></TR></TABLE> >];

MinLibBytes[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MinLibBytes</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    truncateInPlace(bytes,uint256)</TD></TR><TR><TD align="left">    readAddress(bytes,uint256)</TD></TR><TR><TD align="left">    readBytes32(bytes,uint256)</TD></TR><TR><TD align="left">    readUint256(bytes,uint256)</TD></TR><TR><TD align="left">    readBytes4(bytes,uint256)</TD></TR></TABLE> >];

Counters[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Counters</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    current(Counters.Counter)</TD></TR><TR><TD align="left">    increment(Counters.Counter)</TD></TR><TR><TD align="left">    decrement(Counters.Counter)</TD></TR></TABLE> >];

IRelayHub[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IRelayHub</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    addRelayWorkers(address[])</TD></TR><TR><TD align="left">    registerRelayServer(uint256,uint256,string)</TD></TR><TR><TD align="left">    depositFor(address)</TD></TR><TR><TD align="left">    withdraw(uint256,address)</TD></TR><TR><TD align="left">    relayCall(uint256,GsnTypes.RelayRequest,bytes,bytes,uint256)</TD></TR><TR><TD align="left">    penalize(address,address)</TD></TR><TR><TD align="left">    calculateCharge(uint256,GsnTypes.RelayData)</TD></TR><TR><TD align="left">    stakeManager()</TD></TR><TR><TD align="left">    penalizer()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    minimumStake()</TD></TR><TR><TD align="left">    minimumUnstakeDelay()</TD></TR><TR><TD align="left">    maximumRecipientDeposit()</TD></TR><TR><TD align="left">    postOverhead()</TD></TR><TR><TD align="left">    gasReserve()</TD></TR><TR><TD align="left">    maxWorkerCount()</TD></TR><TR><TD align="left">    workerToManager(address)</TD></TR><TR><TD align="left">    workerCount(address)</TD></TR><TR><TD align="left">    isRelayManagerStaked(address)</TD></TR><TR><TD align="left">    gasOverhead()</TD></TR><TR><TD align="left">    versionHub()</TD></TR></TABLE> >];

IKnowForwarderAddress[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IKnowForwarderAddress</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getTrustedForwarder()</TD></TR></TABLE> >];

IForwarder[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IForwarder</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getNonce(address)</TD></TR><TR><TD align="left">    verify(IForwarder.ForwardRequest,bytes32,bytes32,bytes,bytes)</TD></TR><TR><TD align="left">    execute(IForwarder.ForwardRequest,bytes32,bytes32,bytes,bytes)</TD></TR><TR><TD align="left">    registerRequestType(string,string)</TD></TR><TR><TD align="left">    registerDomainSeparator(string,string)</TD></TR></TABLE> >];

Forwarder -> IForwarder;
Forwarder[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Forwarder</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left"><font color="#FFA500">    getNonce(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    verify(IForwarder.ForwardRequest,bytes32,bytes32,bytes,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    execute(IForwarder.ForwardRequest,bytes32,bytes32,bytes,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    registerRequestType(string,string)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    registerDomainSeparator(string,string)</font></TD></TR><TR><TD align="left">    _getEncoded(IForwarder.ForwardRequest,bytes32,bytes)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _verifyNonce(IForwarder.ForwardRequest)</TD></TR><TR><TD align="left">    _updateNonce(IForwarder.ForwardRequest)</TD></TR><TR><TD align="left">    registerRequestTypeInternal(string)</TD></TR><TR><TD align="left">    _verifySig(IForwarder.ForwardRequest,bytes32,bytes32,bytes,bytes)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    GENERIC_PARAMS</TD></TR><TR><TD align="left">    EIP712_DOMAIN_TYPE</TD></TR><TR><TD align="left">    typeHashes</TD></TR><TR><TD align="left">    domains</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    nonces</TD></TR></TABLE> >];

IRelayRecipient[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IRelayRecipient</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    isTrustedForwarder(address)</TD></TR><TR><TD align="left">    versionRecipient()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

ECDSA[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ECDSA</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    recover(bytes32,bytes)</TD></TR><TR><TD align="left">    toEthSignedMessageHash(bytes32)</TD></TR></TABLE> >];

AccessControl -> Context;
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleMemberCount(bytes32)</TD></TR><TR><TD align="left">    getRoleMember(bytes32,uint256)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    _functionCallWithValue(address,bytes,uint256,string)</TD></TR></TABLE> >];

BadgePaymaster -> BasePaymaster;
BadgePaymaster[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BadgePaymaster</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    setTarget(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    preRelayedCall(GsnTypes.RelayRequest,bytes,bytes,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    postRelayedCall(bytes,bool,uint256,GsnTypes.RelayData)</font></TD></TR><TR><TD align="left">    withdrawAll(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    versionPaymaster()</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    validTargets</TD></TR></TABLE> >];

BaseRelayRecipient -> IRelayRecipient;
BaseRelayRecipient[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BaseRelayRecipient</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    isTrustedForwarder(address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgSender()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _msgData()</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    trustedForwarder</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR></TABLE> >];

EnumerableSet[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EnumerableSet</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _add(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _remove(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _contains(EnumerableSet.Set,bytes32)</TD></TR><TR><TD align="left">    _length(EnumerableSet.Set)</TD></TR><TR><TD align="left">    _at(EnumerableSet.Set,uint256)</TD></TR><TR><TD align="left">    add(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    remove(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    contains(EnumerableSet.AddressSet,address)</TD></TR><TR><TD align="left">    length(EnumerableSet.AddressSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.AddressSet,uint256)</TD></TR><TR><TD align="left">    add(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    remove(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    contains(EnumerableSet.UintSet,uint256)</TD></TR><TR><TD align="left">    length(EnumerableSet.UintSet)</TD></TR><TR><TD align="left">    at(EnumerableSet.UintSet,uint256)</TD></TR></TABLE> >];

IPaymaster[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IPaymaster</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getGasLimits()</TD></TR><TR><TD align="left">    trustedForwarder()</TD></TR><TR><TD align="left">    getHubAddr()</TD></TR><TR><TD align="left">    getRelayHubDeposit()</TD></TR><TR><TD align="left">    preRelayedCall(GsnTypes.RelayRequest,bytes,bytes,uint256)</TD></TR><TR><TD align="left">    postRelayedCall(bytes,bool,uint256,GsnTypes.RelayData)</TD></TR><TR><TD align="left">    versionPaymaster()</TD></TR></TABLE> >];

Migrations[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Migrations</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    setCompleted(uint256)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    restricted()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    owner</TD></TR><TR><TD align="left">    last_completed_migration</TD></TR></TABLE> >];

GsnEip712Library[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GsnEip712Library</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    splitRequest(GsnTypes.RelayRequest)</TD></TR><TR><TD align="left">    verifyForwarderTrusted(GsnTypes.RelayRequest)</TD></TR><TR><TD align="left">    verifySignature(GsnTypes.RelayRequest,bytes)</TD></TR><TR><TD align="left">    verify(GsnTypes.RelayRequest,bytes)</TD></TR><TR><TD align="left">    execute(GsnTypes.RelayRequest,bytes)</TD></TR><TR><TD align="left">    truncateInPlace(bytes)</TD></TR><TR><TD align="left">    domainSeparator(address)</TD></TR><TR><TD align="left">    getChainID()</TD></TR><TR><TD align="left">    hashDomain(GsnEip712Library.EIP712Domain)</TD></TR><TR><TD align="left">    hashRelayData(GsnTypes.RelayData)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    GENERIC_PARAMS</TD></TR><TR><TD align="left">    RELAYDATA_TYPE</TD></TR><TR><TD align="left">    RELAY_REQUEST_NAME</TD></TR><TR><TD align="left">    RELAY_REQUEST_SUFFIX</TD></TR><TR><TD align="left">    RELAY_REQUEST_TYPE</TD></TR><TR><TD align="left">    RELAYDATA_TYPEHASH</TD></TR><TR><TD align="left">    RELAY_REQUEST_TYPEHASH</TD></TR><TR><TD align="left">    EIP712DOMAIN_TYPEHASH</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    MAX_RETURN_SIZE</TD></TR></TABLE> >];

}